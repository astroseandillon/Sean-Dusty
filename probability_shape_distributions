#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Tue Sep 12 10:23:54 2023
@author: Sean Dillon
This code will allow us to specify a probability shape distribution that can 
then be used to calculate the average absorption and scattering cross sections 
over the geometric factors L1 and L2
"""


import time
AA = time.time()
import numpy as np
import matplotlib.pyplot as plt
import scipy.integrate as spit
import os
# from CSA_math import *
# print('hello world')


dust_dir = ['/home/physics/Research/DUSTY/DUSTY/Lib_nk/', 
            "C:/UTSA/Research/DUSTY/DUSTY/Lib_nk/"]


nk_path = dust_dir[0]               #where the dust is 
dust = 'oliv_nk_y.nk'                  #DUST NAME HERE
rho = 3.33 #grams cm**-3            #density
pathy = os.path.join(nk_path, dust) #pipeline is open

wavelen, n_dust, k_dust = np.loadtxt(pathy, skiprows=12, unpack=True)
                                    #lamda, n, and k values are extracted

m = np.array([complex(n_dust[i], k_dust[i]) for i in range(len(wavelen))])
                                    #joins n, k values into complex number

wavelen = wavelen**(-1) * 10000   #Convert wavelen2 to waveLENGTH from waveNUMBER



def probability(dis_name, l1, l2, lmin=0):
    l3 = 1 - l1 - l2
    if dis_name == 'CDE':
        return 2
    elif dis_name == 'CDE2':
        return 120 * l1 * l2 * l3
    elif dis_name == 'ERCDE':
        return 2/((1 - (3*lmin))**2)


def bounds_l1():
    return [0,1]

def bounds_l2(l1):
    return [0,1-l1]



cabs = []
for j in range(len(wavelen)):
    def f(l1, l2, n=m[j], dis_name='ERCDE'):
        b = 1/(n**2 - 1)
        term1 = 1/3 * 1/(b + l1)
        term2 = 1/3 * 1/(b + l2)
        term3 = 1/3 * 1/(b + 1 - l1 - l2)
        # r = np.real((term1 + term2 + term3)*probability(dis_name, l1, l2))
        j = np.imag((term1 + term2 + term3)*probability(dis_name, l1, l2))
        return j
        # return np.real((term1 + term2 + term3)*probability(dis_name, l1, l2)) + np.imag((term1 + term2 + term3)*probability(dis_name, l1, l2))
    cabs.append(spit.nquad(f, [bounds_l2, bounds_l1])[0])


kappa = np.array((cabs))
kappa *= (2 * np.pi / (1e-4*wavelen)) / rho







fig1,ax1 = plt.subplots()
title = 'Benchmark new kappa vs old kappa'
ax1.set(xscale='linear', yscale='log', xlim=(8.5,44), ylim=(1, 10000))
ax1.set_title(title, fontsize=16)
ax1.set_xlabel(r'$\lambda (\mu m)$', fontsize=14)
ax1.set_ylabel(r'$<\kappa>$ cm$^{2}$ g$^{-1}$', fontsize=14)
ax1.plot(wavelen, kappa, label='CDE new')
# ax1.plot(wavelen, kap_cde1, label = 'CDE old')

ax1.legend()
plt.show()














BB=time.time()
print('This took {} seconds to run'.format(BB-AA))
